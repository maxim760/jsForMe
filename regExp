// . - любой символ, кроме \n
//const regExp = /Игорь\./ // экранируем точку
//const str = "Я Игорь. 42 матча лч. Рекордсмен."
//const result = str.match(regExp)
//console.log(result)
//console.log(str.match(/\d\d/))

//  .   любой символ кроме \n (переноса строки)
//
//  \d  Число
//  \D  не Число
//
//  \s  Пробел (и перенос строки, табуляция и тд)
//  \S  не Пробел
//
//  \w  англ.Буквы, Цифры и _  (символьный класс слово)
//  \W  не слово (не буква,не цифра, не _)

// [ЮИ]ра  - набор, найдет либо Юра либо Ира
// [^ЮИ]ра  - набор, любое не Юра и не Ира , можно Ора Ура и тд

// [abc]  - любой символ из данного набор
// [^abc]  - любой символ не из данного набора

// [a-c]   -  диапазон внутри набора
// [^a-c]  - исключающий диапазон

// match - метод для поиска совпадений

//    ---------------------------------------------------------------------    \\
// 2 урок
// _______________________________________________________________

//let regexp = /\d\d\.\d\d\.\d\d\d\d/ // так неудобно
//let str = "Сегодня 01.08.2020"

let regexp = /\d{2}\.\d{2}\.\d{4}/  // квантификатор
let str = "Сегодня 01.08.2020"

let result = str.match(regexp)

// жадные (стараются наибольшее количество раз повторить):
// {n}  -  повторить n раз

regexp = /\d{3,5}/ //либо 3 цифры либо 4 либо 5
let regexpLen = /\d{3,5}?/ //либо 3 цифры либо 4 либо 5
str = "У меня 50р, не хватает ещё 1000"

console.log(str.match(regexp)) // выведет 1000, не 100, тк жадный,пытается
// наибольшее число захватить
console.log(str.match(regexpLen))
// {m,n}  -  повторить от m до n раз, (пытается больше)



// Жадные квантификаторы (стараются наибольшее количество раз повторить)
// {n}  -  повторить n раз
// {m,n}  -  повторить от m до n раз, (пытается больше)
// {m,}  -  повторить от m до бесконечности раз
// ? — {0,1}
// * — {0,}  - от 0 до бесконечности
// + — {1,}  — от 1 до беск.

// Ленивые квантификаторы (стараются наименьшее количество раз повторить)
// {m,n}?
// {m,}?
// ?? - делает ленивым ?
// *? - делает ленивым *
// +? - делает ленивым +

// квантификатор {3,}   - 3 и более раз
// жадный выведет максимально (хоть 100,если строка подходить будет)
// ленивый  -  3


console.log("89922".match(/\d{2,}?/g),'ленивый')
console.log("89922".match(/\d{2,}/g),'жадный')


// /colou?r/  - найдет и color и colour, ? - повторени 0 и 1 раз

// еще методы
// split
regexp =/\s*,\s*/
str = "1,2, 3  ,   4,5,  6  ,7"
result =str.split(regexp)
console.log(result) // останутся только цифры,остальное уйдет как разделить в сплит

// search  -  находит индекс совпадения, если не найдет ,то выведет -1

// УРОК 3
// ФЛАГИ

// g - глобальный поиск
// s - спец.режим, в котром точка ищет все символы(включая перенос строки)
// i - любой регистр
// y - для поиска на заданной позиции lastIndex
// u - флаг для юникодных свойств
// \p{...} например \p{Sc} - поиск значков валют, другие буквы - др. уник. свойства
// m - флаг многострочности


// метод matchAll - это как match,только для флага g ищет болле развернутую инфу
// индекс там и тд
// Array.from(str.matchAll(regexp))

regexp = /кот/gi
str = "Кот терракотового цвета кушает котлету"

//// 2 способ перебрать все совпадения с подробной инфой!!!
//
//let result =regexp.exec(str)
//console.log(result, regexp.lastIndex)
//
//result =regexp.exec(str)
//console.log(result, regexp.lastIndex)
//
//result =regexp.exec(str)
//console.log(result, regexp.lastIndex
//
//result =regexp.exec(str)
console.log(result, regexp.lastIndex)
// в первом нашло кот и ластиндекс=3,сохранило индекс и следующий перебор начинается с этого индекса и так до конца!!!, то есть всегда разный будет,не бужет всегда первое совпадение таким образомможно перебрать

// сразу в массив через такой способ!

result = []
let currentResult = null
while(currentResult = regexp.exec(str)) {
      result = [...result,currentResult]
}
console.log(result)




str = ""
for(let i=0;i < 10000000; i++) {
str += (i == 1000 || i == 2000) ? "b" : "a"
}
//
//regexp = /b/g
//let t1 =performance.now()
//console.log(t1)
//let res1 = regexp.exec(str)
//let res2 = regexp.exec(str)
//let res3 = regexp.exec(str)
//let t2 = performance.now()
//console.log(t2 - t1, res1, res2, res3 )
//
//regexp = /b/y
//let t1 =performance.now()
//console.log(t1)
//let res1 = regexp.exec(str)
//let res2 = regexp.exec(str)
//let res3 = regexp.exec(str)
//let t2 = performance.now()
//console.log(t2 - t1, res1, res2, res3 )


regexp = /b/g
let t1 =performance.now()
regexp.lastIndex = 1000
let res1 = regexp.exec(str)
regexp.lastIndex = 2000
let res2 = regexp.exec(str)
let res3 = regexp.exec(str)
let t2 = performance.now()
console.log(t2 - t1, res1, res2, res3 )


regexp = /b/y
t1 =performance.now()
console.log(t1)
regexp.lastIndex = 1000
res1 = regexp.exec(str)
regexp.lastIndex = 2000
res2 = regexp.exec(str)
res3 = regexp.exec(str)
t2 = performance.now()
console.log(t2 - t1, res1, res2, res3)
// самая быстрая


// урок 4 ЯКОРЯ

//regexp = /[^\s]+/g
//regexp = /^[^\s]+/g
//regexp = /[^\s]+$/g
regexp = /[^\s]+$/gm // многострочность
str = "Я вас любил: любовь еще, быть может,\nВ душе моей угасла не совсем;\nНо пусть она вас больше не тревожит;\nЯ не хочу печалить вас ничем.\nЯ вас любил безмолвно, безнадежно,\nТо робостью, то ревностью томим;\nЯ вас любил так искренно, так нежно,\nКак дай вам бог любимой быть другим."

console.log(str.match(regexp))

// Якоря:

// ^ - начало текста  или строки, если есть флаг m
// $ - конец текста или строки, если есть флаг m
// \b - граница слова 1) между началом текста и не словом
//    - 2) между не словом и словом, и наоборот
//    - 3) между не словом и концом текста
// слово это все что относится к \w
// \B - противоположно b, не граница слова - то что внутри
// test - метод для проверки присутствия совпадения regExp.test(string)


//regexp = /am/g
regexp = /\bam\b/g
str = "Hello, I am a JavaScript programmer... Yes, I am..."
console.log(str.match(regexp))


//let password = document.querySelector("#password")
//
//regexp = /^.{8,16}$/
//password.addEventListener("input", function() {
//    result = regexp.test(this.value)
//    if(result) {
//        password.classList.add("form-input--success")
//        password.classList.remove("form-input--error")
//    } else {
//        password.classList.remove("form-input--success")
//        password.classList.add("form-input--error")
//    }
//})

// УРОК 5
// СКОБОЧНЫЕ ГРУППЫ
//regexp = /[\da-f]{2}[-:][\da-f]{2}[-:][\da-f]{2}[-:][\da-f]{2}[-:][\da-f]{2}[-:][\da-f]{2}/gi
//regexp = /([\da-f]{2}[-:]){5}[\da-f]{2}/gi
//regexp = /(?:[\da-f]{2}[-:]){5}[\da-f]{2}/gi
//regexp = /[\da-f]{2}([-:])(?:[\da-f]{2}[-:]){4}[\da-f]{2}/gi
//regexp = /[\da-f]{2}([-:])(?:[\da-f]{2}\1){4}[\da-f]{2}/gi // \1 - 1 скобочная группа
// скоб группы считаются поп орядку начиная с 1
// \1 - здесь должно быть то же самое что и в 1 скобочной группе
// т.к. в мак адресах идут либо все : либо все - ,смешиваться не могут
// \1 - ссылка на 1ую скобочную группу // теперь будет 4 реза а не 5
// с номера не оч. удобно
regexp = /[\da-f]{2}(?<razdel>[-:])(?:[\da-f]{2}\k<razdel>){4}[\da-f]{2}/gi


str = `
    ARP-таблица:
    Физический адрес        IP-адрес
    c8-2b-35-9a-a6-1e       192.168.1.1
    00:11:92:b3:a8:0d       192.168.1.132
    ff-ff-ff-ff:ff-ff       192.168.1.255
    01-00-5e-00-00-16       224.0.0.22
    01:00:5e:00:00:fb       224.0.0.251
`

result = []
currentResult = null
while(currentResult = regexp.exec(str)){
    result = [...result,currentResult]
}
console.log(result)

//regexp = /(\w+)\s(\w+)/
regexp = /(?<first>\w+)\s(?<last>\w+)/
str = "Меня зовут Igor Sidorov. А тебя?"

//result = str.match(regexp)
//result = str.replace(regexp, "$&")
//result = str.replace(regexp, "$`")
//result = str.replace(regexp, "$'")
//result = str.replace(regexp, "$2 $1")
//result = str.replace(regexp, "$<last> $<first>")
//result = str.replace(regexp, "$$")
//result = str.replace(regexp, "Игорь Сидоров")
result = str.replace(regexp, (match,p1,p2,index,input,groups) => {
    console.log(match , "match" )
    console.log(p1 , "p1" )
    console.log(p2 , "p2" )
    console.log(index , "index" )
    console.log(input , "input" )
    console.log(groups , "groups" )
    return `${p2} ${p1}`
})
console.log(result)

// () - скобочная группа
// (?:) - скобочная группа исключенная из запоминания
// \n - обратная сслыка , где n - номер скобочной группы
// (?<name>) - название скобочной группа(именованная скобочная группа)
// \k<name> - обратная ссылка , где name - название скобочной группы

// replace - метод для замены, который имеет ряд спец. символом
// $& - вставляет всё найденное совпадение
// $` - вставляет часть строки до совпадения
// $' - вставляет часть строки после совпадения
// $n - обрантая ссылка где n - номер скобочной группы
// $<name> - обратная ссылка в шаблоне, где name - название скобочной группы
// $$ - вставляет $ (\$ тоже вставляет $)


// УРОК 6
// Опережающие и ретроспективные проверки, альтернация

//regexp = /b|d/g
//str = "abcdef"

//regexp = /(?:[01]\d|2[0-3]):[0-5]\d/g
//str = "Завтрак в 09:05. Обед в 15:45. Ужин в 20:50."
//
//result = str.match(regexp)
//console.log(result)

//regexp = /\d+\b(?=\sрублей)/g
//regexp = /\d+\b(?!\sрублей)/g
//regexp = /(?<=заказ\s)\b\d+/g
//regexp = /(?<!заказ\s)\b\d+/g
regexp = /\d+\b(?=\s(рублей))/g // если хотим сохранить опережающее/ретроспективное условие то вокруг нужного добавляем скобки!!!
str = "Ваш заказ 87, с вас 475 рублей... Вот ваша сдача 25 рублей."
// сделаем чтобы слово "рублей попало в ответ"
//result = str.match(regexp)
result = []
currentResult = null
while(currentResult = regexp.exec(str)){
    result = [...result, currentResult]
}
console.log(result)
for(res of result){
    console.log([...res].join(" "))
}

//regexp = /[a-zA-Z\d]/g
//regexp = /(?=[a-z])[a-zA-Z\d]/g
//regexp = /(?=[A-Z]*?[a-z])(?=[a-z]?[A-Z])[a-zA-Z\d]{2}/g
regexp = /(?=[A-Z\d]*?[a-z])(?=[a-z\d]*?[A-Z])(?=[a-zA-Z]*?[\d])[a-zA-Z\d]+/g
str = `
    a B
    aa aB Ba BB
    1aa a1a aa1
    1aB a1B aB1
    1BB B1B BB1
`

result = str.match(regexp)
console.log(result)

// | — или (альтернация)
// x(?=y) - x, если за ним следует у - позитивная опережающая проверка
// x(?!y) - x, если за ним НЕ следует у - негативная опережающая проверка
// (?<=y)x - x, если он следует за  у - позитивная ретроспективная проверка
// (?<!y)x - x, если он НЕ следует за  у - негативная ретроспективная проверка



let password = document.querySelector("#password")

regexp =  /^(?=\S*?[a-z])(?=\S*?[A-Z])(?=\S*?\d)[\p{P}\w]{8,16}$/u
// от 8 до 16 непробельных символов так, чтобы была заглавная буква, обычная буква и цифра!
// если проблеьные символы можно, то заменяем /S на .
password.addEventListener("input", function() {
    result = regexp.test(this.value)
    if(result) {
        password.classList.add("form-input--success")
        password.classList.remove("form-input--error")
    } else {
        password.classList.remove("form-input--success")
        password.classList.add("form-input--error")
    }
})

// \p{P} - все знаки препинания
// \p{Ll} - буквы в нижнем регистре (любой алфавит)
// \p{Lu} - буквы в верхнем регистре (любой алфавит)

// ИТОГ // = _ ! _ ! _ = \\ ИТОГ \\
//======================================================

//  .   любой символ кроме \n (переноса строки)
//
//  \d  Число
//  \D  не Число
//
//  \s  Пробел (и перенос строки, табуляция и тд)
//  \S  не Пробел
//
//  \w  англ.Буквы, Цифры и _  (символьный класс слово)
//  \W  не слово (не буква,не цифра, не _)

// [ЮИ]ра  - набор, найдет либо Юра либо Ира
// [^ЮИ]ра  - набор, любое не Юра и не Ира , можно Ора Ура и тд

// [abc]  - любой символ из данного набор
// [^abc]  - любой символ не из данного набора

// [a-c]   -  диапазон внутри набора
// [^a-c]  - исключающий диапазон

// match - метод для поиска совпадений result = str.match(regexp)

// Жадные квантификаторы (стараются наибольшее количество раз повторить)
// {n}  -  повторить n раз
// {m,n}  -  повторить от m до n раз, (пытается больше)
// {m,}  -  повторить от m до бесконечности раз
// ? — {0,1}
// * — {0,}  - от 0 до бесконечности
// + — {1,}  — от 1 до беск.

// Ленивые квантификаторы (стараются наименьшее количество раз повторить)
// {m,n}?
// {m,}?
// ?? - делает ленивым ?
// *? - делает ленивым *
// +? - делает ленивым +

// квантификатор {3,}   - 3 и более раз
// жадный выведет максимально (хоть 100,если строка подходить будет)
// ленивый  -  3 или минимум

// split - метод для разбиения str.split(regexp)
// search - находит индекс совпадения, иначе выведет -1 str.split(regexp)

// ФЛАГИ

// g - глобальный поиск
// s - спец.режим, в котром точка ищет все символы(включая перенос строки)
// i - любой регистр
// y - для поиска на заданной позиции lastIndex
// u - флаг для юникодных свойств
// m - флаг многострочности

// \p{...} например \p{Sc} - поиск значков валют, другие буквы - др. уник. свойства
// \p{P} - все знаки препинания
// \p{Ll} - буквы в нижнем регистре (любой алфавит)
// \p{Lu} - буквы в верхнем регистре (любой алфавит)


// метод matchAll - это как match,только для флага g ищет болле развернутую инфу
// индекс там и тд
// Array.from(str.matchAll(regexp))

// или 2 способ

//let result = []
//let currentResult = null
//while(currentResult = regexp.exec(str)) {
//      result = [...result,currentResult]
//}
//console.log(result)

//regexp = /b/y
//t1 =performance.now()
//console.log(t1)
//regexp.lastIndex = 1000
//res1 = regexp.exec(str)
//regexp.lastIndex = 2000
//res2 = regexp.exec(str)
//res3 = regexp.exec(str)
//t2 = performance.now()
//console.log(t2 - t1, res1, res2, res3)
// самая быстрая

//regexp.lastIndex = число - задает индекс

// Якоря:

// ^ - начало текста  или строки, если есть флаг m
// $ - конец текста или строки, если есть флаг m
// \b - граница слова 1) Начало текста, если его первый символ \w.
//    - 2) между не словом и словом, и наоборот
//    - 3) Конец текста, если его последний символ \w.
// слово это все что относится к \w
// \B - противоположно b, не граница слова - то что внутри
// test - метод для проверки присутствия совпадения regExp.test(string)

// () - скобочная группа
// (?:) - скобочная группа исключенная из запоминания
// \n - обратная сслыка , где n - номер скобочной группы
// (?<name>) - название скобочной группа(именованная скобочная группа)
// \k<name> - обратная ссылка , где name - название скобочной группы

// replace - метод для замены, который имеет ряд спец. символов
// $& - вставляет всё найденное совпадение
// $` - вставляет часть строки до совпадения
// $' - вставляет часть строки после совпадения
// $n - обрантая ссылка где n - номер скобочной группы
// $<name> - обратная ссылка в шаблоне, где name - название скобочной группы
// $$ - вставляет $ (\$ тоже вставляет $)


// | — или (альтернация)
// x(?=y) - x, если за ним следует у - позитивная опережающая проверка
// x(?!y) - x, если за ним НЕ следует у - негативная опережающая проверка
// (?<=y)x - x, если он следует за  у - позитивная ретроспективная проверка
// (?<!y)x - x, если он НЕ следует за  у - негативная ретроспективная проверка



//regexp = /\d+\b(?=\s(рублей))/g // если хотим сохранить опережающее/ретроспективное условие то вокруг нужного добавляем скобки!!!

// сделаем чтобы слово "рублей попало в ответ"
//result = []
//currentResult = null
//while(currentResult = regexp.exec(str)){
//    result = [...result, currentResult]
//}
//console.log(result)
//for(res of result){
//    console.log([...res].join(" "))
//}

// для пароля
//regexp =  /^(?=\S*?[a-z])(?=\S*?[A-Z])(?=\S*?\d)[\p{P}\w]{8,16}$/u


















